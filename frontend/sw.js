/**\n * SANTOO - Service Worker\n * PWA caching and offline functionality\n */\n\nconst CACHE_NAME = 'santoo-v1.0.0';\nconst OFFLINE_URL = '/offline.html';\n\n// Files to cache for offline functionality\nconst CACHE_FILES = [\n  '/',\n  '/index.html',\n  '/css/reset.css',\n  '/css/variables.css',\n  '/css/components.css',\n  '/css/main.css',\n  '/js/utils.js',\n  '/js/components.js',\n  '/js/auth.js',\n  '/js/upload.js',\n  '/js/video-player.js',\n  '/js/main.js',\n  '/assets/images/default-avatar.svg',\n  '/manifest.json'\n];\n\n/**\n * Install event - cache essential files\n */\nself.addEventListener('install', (event) => {\n  console.log('📦 SW: Installing service worker...');\n  \n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) => {\n        console.log('📦 SW: Caching app shell files');\n        return cache.addAll(CACHE_FILES);\n      })\n      .then(() => {\n        console.log('✅ SW: App shell cached successfully');\n        return self.skipWaiting();\n      })\n      .catch((error) => {\n        console.error('❌ SW: Error caching files:', error);\n      })\n  );\n});\n\n/**\n * Activate event - clean up old caches\n */\nself.addEventListener('activate', (event) => {\n  console.log('🔄 SW: Activating service worker...');\n  \n  event.waitUntil(\n    caches.keys()\n      .then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            if (cacheName !== CACHE_NAME) {\n              console.log('🗑️ SW: Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => {\n        console.log('✅ SW: Service worker activated');\n        return self.clients.claim();\n      })\n  );\n});\n\n/**\n * Fetch event - serve cached files or fetch from network\n */\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n  \n  // Skip non-GET requests and chrome-extension requests\n  if (request.method !== 'GET' || url.protocol === 'chrome-extension:') {\n    return;\n  }\n  \n  // Handle navigation requests (HTML pages)\n  if (request.mode === 'navigate') {\n    event.respondWith(\n      fetch(request)\n        .then((response) => {\n          // If fetch succeeds, return the response\n          return response;\n        })\n        .catch(() => {\n          // If fetch fails, return cached index.html or offline page\n          return caches.match('/index.html')\n            .then((cachedResponse) => {\n              return cachedResponse || caches.match(OFFLINE_URL);\n            });\n        })\n    );\n    return;\n  }\n  \n  // Handle other requests with cache-first strategy\n  event.respondWith(\n    caches.match(request)\n      .then((cachedResponse) => {\n        if (cachedResponse) {\n          console.log('📥 SW: Serving from cache:', request.url);\n          return cachedResponse;\n        }\n        \n        // If not in cache, fetch from network\n        return fetch(request)\n          .then((response) => {\n            // Don't cache if not a successful response\n            if (!response || response.status !== 200 || response.type !== 'basic') {\n              return response;\n            }\n            \n            // Clone the response for caching\n            const responseToCache = response.clone();\n            \n            // Cache the response for future requests\n            caches.open(CACHE_NAME)\n              .then((cache) => {\n                // Only cache certain file types\n                if (shouldCache(request.url)) {\n                  console.log('💾 SW: Caching new resource:', request.url);\n                  cache.put(request, responseToCache);\n                }\n              });\n            \n            return response;\n          })\n          .catch((error) => {\n            console.error('❌ SW: Network request failed:', request.url, error);\n            \n            // For images, return a placeholder\n            if (request.destination === 'image') {\n              return caches.match('/assets/images/default-avatar.svg');\n            }\n            \n            // For other requests, return a generic offline response\n            return new Response(\n              JSON.stringify({ \n                error: 'Offline', \n                message: 'Recurso não disponível offline' \n              }), \n              {\n                status: 503,\n                statusText: 'Service Unavailable',\n                headers: new Headers({\n                  'Content-Type': 'application/json'\n                })\n              }\n            );\n          });\n      })\n  );\n});\n\n/**\n * Message event - handle messages from the app\n */\nself.addEventListener('message', (event) => {\n  console.log('💬 SW: Received message:', event.data);\n  \n  switch (event.data.type) {\n    case 'SKIP_WAITING':\n      self.skipWaiting();\n      break;\n      \n    case 'CACHE_URLS':\n      if (event.data.payload && event.data.payload.length > 0) {\n        caches.open(CACHE_NAME)\n          .then((cache) => {\n            return cache.addAll(event.data.payload);\n          })\n          .then(() => {\n            console.log('✅ SW: URLs cached successfully');\n          })\n          .catch((error) => {\n            console.error('❌ SW: Error caching URLs:', error);\n          });\n      }\n      break;\n      \n    default:\n      console.log('🤷 SW: Unknown message type:', event.data.type);\n  }\n});\n\n/**\n * Push event - handle push notifications\n */\nself.addEventListener('push', (event) => {\n  console.log('🔔 SW: Push notification received:', event.data?.text());\n  \n  const options = {\n    body: event.data?.text() || 'Nova notificação do Santoo',\n    icon: '/assets/icons/icon-192x192.png',\n    badge: '/assets/icons/badge-72x72.png',\n    tag: 'santoo-notification',\n    vibrate: [200, 100, 200],\n    actions: [\n      {\n        action: 'open',\n        title: 'Abrir App',\n        icon: '/assets/icons/open-action.png'\n      },\n      {\n        action: 'close',\n        title: 'Fechar',\n        icon: '/assets/icons/close-action.png'\n      }\n    ]\n  };\n  \n  event.waitUntil(\n    self.registration.showNotification('Santoo', options)\n  );\n});\n\n/**\n * Notification click event\n */\nself.addEventListener('notificationclick', (event) => {\n  console.log('🔔 SW: Notification clicked:', event.action);\n  \n  event.notification.close();\n  \n  if (event.action === 'open' || !event.action) {\n    event.waitUntil(\n      clients.openWindow('/')\n    );\n  }\n});\n\n/**\n * Background sync event\n */\nself.addEventListener('sync', (event) => {\n  console.log('🔄 SW: Background sync triggered:', event.tag);\n  \n  if (event.tag === 'background-sync') {\n    event.waitUntil(doBackgroundSync());\n  }\n});\n\n/**\n * Utility functions\n */\n\n/**\n * Check if URL should be cached\n */\nfunction shouldCache(url) {\n  const cacheableExtensions = [\n    '.html', '.css', '.js', '.png', '.jpg', '.jpeg', '.svg', '.webp',\n    '.woff', '.woff2', '.ttf', '.eot', '.json'\n  ];\n  \n  return cacheableExtensions.some(ext => url.toLowerCase().includes(ext));\n}\n\n/**\n * Perform background sync operations\n */\nasync function doBackgroundSync() {\n  try {\n    console.log('🔄 SW: Performing background sync...');\n    \n    // Here you would typically:\n    // - Send queued uploads\n    // - Sync offline actions\n    // - Update cached content\n    \n    console.log('✅ SW: Background sync completed');\n  } catch (error) {\n    console.error('❌ SW: Background sync failed:', error);\n    throw error; // This will retry the sync\n  }\n}\n\nconsole.log('🚀 SW: Service worker script loaded');"